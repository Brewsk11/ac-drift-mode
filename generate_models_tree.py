#!/usr/bin/env python
import os
from pathlib import Path

MODELS_FILE = "lua_libs/drift-mode/models.lua"
MODELS_DIR = "lua_libs/drift-mode/models"
RELATIVE_TO = "lua_libs"

# This script has been all vibe-coded, it's awful but it works.
# I have to refactor it some time..


# --- Helper to compute require‑paths ----------------------------------------------
def _relative_require_path(file_path: Path, base_dir: Path) -> str:
    """
    Return a path suitable for a Lua `require` statement:
      * relative to `base_dir`
      * no file extension
      * uses forward slashes
    """
    relative = file_path.relative_to(base_dir).with_suffix("")
    return str(relative).replace("\\", "/")


class LuaTableWriter:
    def __init__(self):
        self.file_path: str = MODELS_FILE
        self.current_depth = 0
        self.indent_size = 4
        self.comma_needed = False

    def open(self):
        self.file = open(self.file_path, "w")
        self.file.write(f"-- This file is autogenerated by {Path(__file__).name}\n")
        self.file.write("-- Do not edit manually\n\n")
        self.file.write("-- Load models to global namespace\n\n")

    def close(self):
        self.file.close()

    def startTable(self, symbol):
        if self.current_depth > 0 and self.comma_needed:
            self.file.write(",")
        self.file.write("\n")
        self.file.write(" " * self.indent_size * self.current_depth)
        self.file.write(symbol + " = {")
        self.current_depth += 1
        self.comma_needed = False

    def endTable(self):
        self.file.write("\n")
        self.current_depth -= 1
        self.file.write(" " * self.indent_size * self.current_depth)
        self.file.write("}")
        self.comma_needed = True

    def writeRequire(self, symbol, path):
        if self.current_depth > 0 and self.comma_needed:
            self.file.write(",")
        self.file.write("\n")
        self.file.write(" " * self.indent_size * self.current_depth)
        self.file.write(f'{symbol} = require("{path}")')
        self.comma_needed = True


writer = LuaTableWriter()


# ----------------------------------------------------------------
# --- write_subdir_file (refactored) -----------------------------------------------
def write_subdir_file(subdir_path: str, subdir_name: str) -> None:
    """
    Create `<subdir_name>.lua` in the parent directory of *subdir_path*.
    The module will expose:
        - every .lua file inside *subdir_path*
        - every immediate sub‑directory inside *subdir_path* as a require
          unless a file with the same name already exists.
    """
    subdir = Path(subdir_path)
    parent_dir = subdir.parent
    lua_file = parent_dir / f"{subdir_name}.lua"

    # Collect file names (without extension) to avoid duplicate symbols
    file_names = {p.stem for p in subdir.iterdir() if p.is_file()}

    with lua_file.open("w", encoding="utf-8") as f:
        f.write(f"-- This file is autogenerated by {Path(__file__).name}\n")
        f.write("-- Do not edit manually\n\n")
        f.write(f"local {subdir_name} = {{\n")

        # Files inside the sub‑directory
        for file in subdir.iterdir():
            if file.is_file():
                name = file.stem
                rel_path = _relative_require_path(file, Path(RELATIVE_TO))
                f.write(f'  {name} = require("{rel_path}"),\n')

        # Immediate sub‑directories (skip if name already used by a file)
        for dir_ in subdir.iterdir():
            if dir_.is_dir() and dir_.name not in file_names:
                nested_name = dir_.name
                nested_rel = _relative_require_path(dir_, Path(RELATIVE_TO))
                f.write(f'  {nested_name} = require("{nested_rel}"),\n')

        f.write("}\n")
        f.write(f"return {subdir_name}\n")


# --- visitDir (refactored to use Path and the helper) ----------------------------
def visitDir(dir_path: str, top: bool = True) -> None:
    """
    Traverse *dir_path* and generate require statements.
    *top* controls whether we emit a require into the top‑level file.
    """
    dir_ = Path(dir_path)

    # Keep track of top‑level file names (without extension) to avoid duplicates
    top_file_names = {p.stem for p in dir_.iterdir() if p.is_file()}

    for obj in dir_.iterdir():
        if obj.is_dir():
            # Create sibling module for this directory
            write_subdir_file(str(obj), obj.name)

            if top and obj.name not in top_file_names:
                rel_path = _relative_require_path(obj, Path(RELATIVE_TO))
                writer.writeRequire(obj.name, rel_path)

            # Recurse into the sub‑directory (no top‑level requires inside)
            visitDir(str(obj), top=False)

        elif obj.is_file() and top:
            # Emit top‑level file requires (already ensured no duplicate name)
            name = obj.stem
            path = _relative_require_path(obj, Path(RELATIVE_TO))
            writer.writeRequire(name, path)


# --- Run the generation ------------------------------------------------------------
writer = LuaTableWriter()
writer.open()
visitDir(MODELS_DIR)
writer.file.write("\n")
writer.close()
